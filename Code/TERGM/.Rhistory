require(doParallel)
require(foreach)
# ergm_call should be an expression
# time fixed effects are required
# formula should include all pooled terms in offset()
# network should be called 'net' in the formula
# edgecovs should be a T x Number_of_edgecovs length named list of matrices
# , where names(list_of_edgecovs[[t]])[i] is the matrix name used in the
# model formula
## Doing individual ergm estimation for pooling
registerDoParallel(cores=ncores)
ergms <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call_no_offset)
}
stopImplicitCluster()
print("finished stage 1")
coefMat <- NULL
weightMat <- NULL
meta.coef <- 0
varDenom <- 0
for(i in 1:length(list_of_networks)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
coefMat <- rbind(coefMat,coef(ergms[[i]]))
weightMat <- rbind(weightMat,1/(summary(ergms[[i]])$asyse)^2)
varDenom <- varDenom + weightMat[i,]
meta.coef <- meta.coef + coefMat[i,]*weightMat[i,]
}
meta.coef <- meta.coef/varDenom
SE <- sqrt(1/varDenom)
pooled_par <- meta.coef[-1]
registerDoParallel(cores=ncores)
ergms.pooled <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call)
}
stopImplicitCluster()
print("finished stage 2")
coefs <- meta.coef[-1]
SE  <- SE[-1]
loglik <- 0
for(i in 1:length(ergms.pooled)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
loglik <- loglik + as.numeric(logLik(ergms.pooled[[i]]))
coefs <- c(coefs,coef(ergms.pooled[[i]])[1])
SE <- c(SE,summary(ergms.pooled[[i]])$asyse[1])
}
AIC <- 2*length(coefs)-2*loglik
list(estimate=coefs,SE=SE,AIC=AIC,pooled.ergms=ergms.pooled)
}
### Load Libraries
library(ergm)
### Read in data
load("fdi_cov.Rdata")
load("fdi_net.Rdata")
list.edge.attributes(netlist[[1]])
netlist[[1]]
netlist[[1]]$ajd
netlist[[1]]$adj
netlist[[1]]$full
netlist[[1]]$Value_ln
netlist[[1]]$gdp.pc
netlist[["Value_ln"]]
ergm.call <- expression(ergm(net ~ sum, #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
#offset(nodeicov("polity"))+offset(nodeocov("polity"))+
#offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
#offset(nodeicov("pop"))+offset(nodeocov("pop"))+
#offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
#offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
#offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
#offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
#offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum, #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
#nodeicov("polity")+nodeocov("polity")+
#nodeicov("trade_opennes")+nodeocov("trade_opennes")+
#nodeicov("pop")+nodeocov("pop")+
#nodeicov("gdp.pc")+nodeocov("gdp.pc")+
#edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
#edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
#edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
#edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the partially pooled ergm conducts a two-step meta analysis
# in the first step, coefficients are estimated for each network individually
# in the second step, all effects are fixed at the fixed effects meta analysis estimate, and only the
# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
ergm.call <- expression(ergm(net ~ sum + sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
offset(nodeicov("polity"))+offset(nodeocov("polity")),
#offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
#offset(nodeicov("pop"))+offset(nodeocov("pop"))+
#offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
#offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
#offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
#offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
#offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum + sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
nodeicov("polity")+nodeocov("polity"),
#nodeicov("trade_opennes")+nodeocov("trade_opennes")+
#nodeicov("pop")+nodeocov("pop")+
#nodeicov("gdp.pc")+nodeocov("gdp.pc")+
#edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
#edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
#edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
#edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the partially pooled ergm conducts a two-step meta analysis
# in the first step, coefficients are estimated for each network individually
# in the second step, all effects are fixed at the fixed effects meta analysis estimate, and only the
# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
# clear workspace, set seed, and set wd
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
ergmPooledMeta <- function(list_of_networks,ergm_call,ergm_call_no_offset,list_of_edgecovs=NULL,seed=1234,ncores=2){
require(ergm)
require(ergm.count)
require(doParallel)
require(foreach)
## Doing individual ergm estimation for pooling
registerDoParallel(cores=ncores)
ergms <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call_no_offset)
}
stopImplicitCluster()
print("finished stage 1")
coefMat <- NULL
weightMat <- NULL
meta.coef <- 0
varDenom <- 0
for(i in 1:length(list_of_networks)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
coefMat <- rbind(coefMat,coef(ergms[[i]]))
weightMat <- rbind(weightMat,1/(summary(ergms[[i]])$asyse)^2)
varDenom <- varDenom + weightMat[i,]
meta.coef <- meta.coef + coefMat[i,]*weightMat[i,]
}
meta.coef <- meta.coef/varDenom
SE <- sqrt(1/varDenom)
pooled_par <- meta.coef[-1]
registerDoParallel(cores=ncores)
ergms.pooled <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call)
}
stopImplicitCluster()
print("finished stage 2")
coefs <- meta.coef[-1]
SE  <- SE[-1]
loglik <- 0
for(i in 1:length(ergms.pooled)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
loglik <- loglik + as.numeric(logLik(ergms.pooled[[i]]))
coefs <- c(coefs,coef(ergms.pooled[[i]])[1])
SE <- c(SE,summary(ergms.pooled[[i]])$asyse[1])
}
AIC <- 2*length(coefs)-2*loglik
list(estimate=coefs,SE=SE,AIC=AIC,pooled.ergms=ergms.pooled)
}
### Load Libraries
library(ergm)
### Read in data
load("fdi_cov.Rdata")
load("fdi_net.Rdata")
ergm.call <- expression(ergm(net ~ sum + sum(pow=1/2)+ nonzero +
mutual(form="min")+transitiveweights("min", "max", "min")+
offset(nodeicov("polity"))+offset(nodeocov("polity"))+
offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
offset(nodeicov("pop"))+offset(nodeocov("pop"))+
offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum + sum(pow=1/2)+ nonzero +
mutual(form="min")+transitiveweights("min", "max", "min")+
nodeicov("polity")+nodeocov("polity")+
nodeicov("trade_opennes")+nodeocov("trade_opennes")+
nodeicov("pop")+nodeocov("pop")+
nodeicov("gdp.pc")+nodeocov("gdp.pc")+
edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the pa
# clear workspace
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#load packages
library(magic)
library(network)
library(igraph)
library(doBy)
library(plyr)
library(DataCombine)
#setwd("/Users/johnpschoeneman/Desktop/ACI/Count")
#load in data
fdi <- read.csv("sub_stock.csv", stringsAsFactors=FALSE)        #FDI
fdi <- fdi[,-1]
# create new variable transformations
fdi$trade_ln <- log(fdi$trade_int+fdi$trade_hco+fdi$trade_cap+fdi$trade_mix+1)
fdi$dyad <- paste(fdi$Destination, fdi$Origin, sep = "")
fdi$mass <- (log(fdi$Dest.GDP*fdi$Origin.GDP))
fdi$dist_ln <- log(fdi$dist)
fdi$Value_ln <- round(log(ifelse(fdi$Value<0, 0, fdi$Value)+1))
fdi$Dest.pop_ln <- log(fdi$Dest.pop)
fdi$Origin.pop_ln <- log(fdi$Origin.pop)
#lag DV and GDP (to create growth rates)
fdi <- slide(fdi, Var = "Dest.GDP", GroupVar = "dyad", slideBy = -1)
fdi <- slide(fdi, Var = "Origin.GDP", GroupVar = "dyad", slideBy = -1)
fdi <- slide(fdi, Var = "Value_ln", GroupVar = "dyad", slideBy = -1)
#Create GDP pc (logged) and growth rate
fdi$Origin.GDPpc_ln <- log(fdi$Origin.GDP/fdi$Origin.pop)
fdi$Dest.GDPpc_ln <- log(fdi$Dest.GDP/fdi$Dest.pop)
fdi$Origin.GDPg <- (fdi$Origin.GDP-fdi$`Origin.GDP-1`)/fdi$`Origin.GDP-1`
fdi$Dest.GDPg <- (fdi$Dest.GDP-fdi$`Dest.GDP-1`)/fdi$`Dest.GDP-1`
fdi$Value_h <- ifelse(fdi$Value < 0, 0, fdi$Value)
fdi_col <- subset(fdi, fdi$Value_ln == 0)
fdi_h <- subset(fdi, fdi$Value_ln != 0)
fdi_col$Value  <- 1
fdi_col <- summaryBy(Value~Year, data = fdi_col, FUN=sum)
fdi_col$prop <- fdi_col$Value.sum/15500
par(mar = c(5,5,5,5))
boxplot(fdi_h$Value_h~fdi_h$Year, log = "y",col="lightgray", main = "Non-Zero FDI Stocks",yaxt='n',
xlab="Year", ylab = "FDI Stock (in mil USD)",outline=TRUE, cex=0.5, pch = 16, par(las=1))
axis(2,at=c(1, 100, 10000),labels=c("1","100","10K"))
par(new = T)
plot(fdi_col$prop, axes=F, xlab=NA, ylab=NA, type="l", col = "#D55E00", pch = 16)
axis(side = 4, col = "#D55E00", col.axis ="#D55E00",col.ticks="#D55E00")
par(las=0)
mtext(side = 4, line = 3, 'Proportion of Zeroes', col ="#D55E00")
rm(fdi_col, fdi_h)
# create alliance dummy
fdi$alliance <- (fdi$nonaggression.max.x + fdi$entente.max.x + fdi$neutrality.max.x)
fdi$alliance <- as.numeric(ifelse(fdi$alliance >0, 1, 0))
#make bit  and defense numeric
fdi$bit_dummy <- as.numeric(fdi$bit_dummy)
fdi$defense.max.x <- as.numeric(fdi$defense.max.x)
dichot <- summaryBy(bit_dummy + alliance + defense.max.x~Year, data = fdi, FUN=sum)
View(dichot)
fdi <- na.omit(fdi)
dichot <- summaryBy(bit_dummy + alliance + defense.max.x~Year, data = fdi, FUN=sum)
170500/11
(length(fdi)/length(unique(fdi$Year)))
(length(fdi$Year)/length(unique(fdi$Year)))
dichot[,2:4] <- dichot[,2:4]/(length(fdi$Year)/length(unique(fdi$Year)))
View(dichot)
bit <- table(dichot$bit_dummy.sum)
rm(bit)
barplot(dichot$bit_dummy.sum~dichot$Year, main="Proportion of BIT dyads",
xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads", col="lightgray",
yaxt='n', par(las=1), xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads", col="lightgray",
yaxt='n', par(las=1), outline=TRUE,xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads", #col="lightgray",
yaxt='n', par(las=1), outline=TRUE,xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads", #col="lightgray",
par(las=1), outline=TRUE,xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads", #col="lightgray",
yaxt='n',xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
yaxt='n',xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
yaxt='n',xlab="Year", outline=TRUE)
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2001, 2012, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
yaxt='n',xlab="Year")
dichot <- summaryBy(bit_dummy + alliance + defense.max.x~Year, data = fdi, FUN=sum)
dichot[,2:4] <- dichot[,2:4]/(length(fdi$Year)/length(unique(fdi$Year)))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
yaxt='n',xlab="Year")
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2001, 2012, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
yaxt='n',xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2001, 2012, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
axis(1,at=seq(2001, 2011, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
seq(2001, 2011, 2)
axis(4,at=seq(2001, 2011, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
col="lightgray",yaxt='n',xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2001, 2011, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
col="lightgray",xlab="Year")
axis(1,labels=c("2001", "2003","2005", "2007", "2009", "2011"))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
col="lightgray",yaxt='n',xlab="Year", xaxt=TRUE)
dichot <- summaryBy(bit_dummy + alliance + defense.max.x~Year, data = fdi, FUN=sum)
dichot[,2:4] <- dichot[,2:4]/(length(fdi$Year)/length(unique(fdi$Year)))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2001, 2011, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
View(dichot)
axis(1,at=seq(2002, 2012, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
dichot <- summaryBy(bit_dummy + alliance + defense.max.x~Year, data = fdi, FUN=sum)
dichot[,2:4] <- dichot[,2:4]/(length(fdi$Year)/length(unique(fdi$Year)))
barplot(dichot$bit_dummy.sum, dichot$Year, main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2002, 2012, 2),labels=c("2001", "2003","2005", "2007", "2009", "2011"))
seq(2002, 2012, 2)
axis(1,at=seq(2002, 2012, 2),labels=c("2002", "2004","2006", "2008", "2010", "2012"))
barplot(dichot$bit_dummy.sum,  main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
?barplot
bit <- table(dichot$bit_dummy.sum)
bit <- table(dichot$bit_dummy.sum, dichot$Year)
barplot(bit, main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
barplot(dichot$bit_dummy.sum,  main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=seq(2002, 2012, 2),labels=c("2002", "2004","2006", "2008", "2010", "2012"))
axis(1,at=seq(1, 12, 2),labels=c("2002", "2004","2006", "2008", "2010", "2012"))
barplot(dichot$bit_dummy.sum,  main="Proportion of BIT dyads",
col="lightgray",axes = TRUE,xlab="Year")
axis(1,at=mp,labels=c("2002", "2004","2006", "2008", "2010", "2012"))
barplot(dichot$bit_dummy.sum,  main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
mp <- barplot(dichot$bit_dummy.sum,  main="Proportion of BIT dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year
)
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes = FALSE,xlab="Year")
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",xlab="Year")
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year")
axis(2,at=seq(0, .6, .01),labels=c("0%","1%","2%", "3%", "4%", "5%", "6%"))
axis(1,at=mp,labels=dichot$Year)
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year")
axis(2,at=seq(0, .06, .01),labels=c("0%","1%","2%", "3%", "4%", "5%", "6%"))
axis(1,at=mp,labels=dichot$Year)
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year", ylim = (.1))
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year", ylim = 1 )
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year", ylim = c(0,1))
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year", ylim = c(0,.1))
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
mp <- barplot(dichot$defense.max.x.sum,  main="Proportion of Defense Treaty Dyads",
col="lightgray",axes = FALSE,xlab="Year")
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
mp <- barplot(dichot$defense.max.x.sum,  main="Proportion of Defense Treaty Dyads",
col="lightgray",axes = FALSE,xlab="Year", ylim = c(0,.1))
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
# Alliance
mp <- barplot(dichot$alliance.sum,  main="Proportion of Alliance Dyads",
col="lightgray",axes=FALSE,xlab="Year", ylim = c(0,.1))
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
#Defense Treaty
mp <- barplot(dichot$defense.max.x.sum,  main="Proportion of Defense Treaty Dyads",
col="lightgray",axes = FALSE,xlab="Year", ylim = c(0,.1))
axis(2,at=seq(0, .1, .02),labels=c("0%","2%","4%", "6%", "8%", "10%"))
axis(1,at=mp,labels=dichot$Year)
rm(dichot, mp, bit)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",yaxt='n',
xlab="Year", ylab = "FDI Stock (in mil USD)", cex=0.5, pch = 16)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",yaxt='n',
xlab="Year", ylab = "Distribution", cex=0.5, pch = 16)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",#yaxt='n',
xlab="Year", ylab = "Distribution", cex=0.5, pch = 16)
summary(fdi$Dest.polity)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",#yaxt='n',
xlab="Year", ylab = "Polity Scale (-10 = Fully Autocratic, 10 = Fully Democratic", cex=0.5, pch = 16)
axis(2,at=c(1, 100, 10000),labels=c("1","100","10K"))
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",#yaxt='n',
xlab="Year", ylab = "Polity Scale (-10 = Fully Autocratic, 10 = Fully Democratic", cex=0.5, pch = 16)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",#yaxt='n',
xlab="Year", ylab = "Polity Scale", cex=0.5, pch = 16)
boxplot(fdi$Dest.TO~fdi$Year, col="lightgray", main = "Trade Openness",#yaxt='n',
xlab="Year", ylab = "% of GDP from IM/EX", cex=0.5, pch = 16)
boxplot(fdi$Dest.TO~fdi$Year, col="lightgray", main = "Trade Openness", yaxt='n',
xlab="Year", ylab = "IM/EX as % of GDP ", cex=0.5, pch = 16)
axis(2,at=seq(0, 400, 100),labels=c("0%","100%","200%", "300%", "400%"))
boxplot(fdi$Dest.TO~fdi$Year, col="lightgray", main = "Population", #yaxt='n',
xlab="Year", ylab = "Population ", cex=0.5, pch = 16)
#gdp.pc
boxplot(fdi$Dest.pop~fdi$Year, col="lightgray", main = "Population", #yaxt='n',
xlab="Year", ylab = "Population ", cex=0.5, pch = 16)
boxplot(fdi$Dest.pop~fdi$Year, log = "y",col="lightgray", main = "Population", #yaxt='n',
xlab="Year", ylab = "Population ", cex=0.5, pch = 16)
summary(fdi$Dest.pop)
boxplot(fdi$Dest.pop~fdi$Year, log = "y",col="lightgray", main = "Population", yaxt='n',
xlab="Year", ylab = "Population in Millions", cex=0.5, pch = 16)
axis(2,at=c(0, 1, 100, 1000, 1500),labels=c("0","1","100","1K", "1.5K"))
boxplot(fdi$Dest.pop~fdi$Year, log = "y",col="lightgray", main = "Population", yaxt='n',
xlab="Year", ylab = "Population in Millions", cex=0.5, pch = 16)
axis(2,at=c(0, 1, 100, 1000),labels=c("0","1","100","1K"))
boxplot(fdi$Dest.GDPpc_ln~fdi$Year, col="lightgray", main = "GDP pc",# yaxt='n',
xlab="Year", ylab = "GDP pc, Logged", cex=0.5, pch = 16)
fdi$Dest.GDPpc <- fdi$Dest.GDP/fdi$Dest.pop
boxplot(fdi$Dest.GDPpc~fdi$Year, col="lightgray", main = "GDP pc",# yaxt='n',
xlab="Year", ylab = "GDP pc, Logged", cex=0.5, pch = 16)
boxplot(fdi$Dest.GDPpc~fdi$Year, col="lightgray", main = "GDP pc", yaxt='n',
xlab="Year", ylab = "GDP pc, Logged", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$Dest.GDPpc~fdi$Year, col="lightgray", main = "GDP pc", yaxt='n',
xlab="Year", ylab = "GDP per capita", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$mass~fdi$Year, col="lightgray", main = "Mass", #yaxt='n',
xlab="Year", ylab = "GDP Product", cex=0.5, pch = 16)
boxplot(fdi$dist~fdi$Year, col="lightgray", main = "Distance", #yaxt='n',
xlab="Year", ylab = "Distance, Miles", cex=0.5, pch = 16)
boxplot(fdi$dist~fdi$Year, col="lightgray", main = "Distance", yaxt='n',
xlab="Year", ylab = "Distance, Miles", cex=0.5, pch = 16)
axis(2,at=c(0, 5000, 10000, 15000, 20000),labels=c("0","5K","10K","15K", "20K"))
boxplot(fdi$trade_ln~fdi$Year, col="lightgray", main = "Trade", #yaxt='n',
xlab="Year", ylab = "Value of Trade", cex=0.5, pch = 16)
boxplot(fdi$Dest.polity~fdi$Year, col="lightgray", main = "Polity",#yaxt='n',
xlab="Year", ylab = "Polity Scale", cex=0.5, pch = 16)
boxplot(fdi$Dest.TO~fdi$Year, col="lightgray", main = "Trade Openness", yaxt='n',
xlab="Year", ylab = "IM/EX as % of GDP ", cex=0.5, pch = 16)
axis(2,at=seq(0, 400, 100),labels=c("0%","100%","200%", "300%", "400%"))
boxplot(fdi$Dest.pop~fdi$Year, log = "y",col="lightgray", main = "Population", yaxt='n',
xlab="Year", ylab = "Population in Millions", cex=0.5, pch = 16)
axis(2,at=c(0, 1, 100, 1000),labels=c("0","1","100","1K"))
boxplot(fdi$Dest.GDPpc~fdi$Year, col="lightgray", main = "GDP pc", yaxt='n',
xlab="Year", ylab = "GDP per capita", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$mass~fdi$Year, col="lightgray", main = "Mass", #yaxt='n',
xlab="Year", ylab = "GDP Product", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$mass~fdi$Year, col="lightgray", main = "Mass", #yaxt='n',
xlab="Year", ylab = "GDP Product of Dyad, Logged", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$dist~fdi$Year, col="lightgray", main = "Distance", yaxt='n',
xlab="Year", ylab = "Distance, Miles", cex=0.5, pch = 16)
axis(2,at=c(0, 5000, 10000, 15000, 20000),labels=c("0","5K","10K","15K", "20K"))
boxplot(fdi$trade_ln~fdi$Year, col="lightgray", main = "Trade", #yaxt='n',
xlab="Year", ylab = "Value of Trade USD in mil, logged", cex=0.5, pch = 16)
axis(2,at=c(0, 50000, 100000, 150000),labels=c("0","50K","100K","150K"))
boxplot(fdi$mass~fdi$Year, col="lightgray", main = "Mass", #yaxt='n',
xlab="Year", ylab = "GDP Product of Dyad, Logged", cex=0.5, pch = 16)

# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
#=============================================================#
# John Schoeneman
# Work Done For: HT Project, OSU
# Date: Summer 2017
# Work Done: Clean up sample dataset
# Machine: MacPro OSX Yosemite
#=============================================================#
# clear workspace, set seed, and set wd
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load need libraries
library(doBy)
# Load in data
dat1 <- read.csv("LA8_20170125.csv", stringsAsFactors=FALSE)
OK <- read.csv("web_scrape_8_OK.csv", stringsAsFactors=FALSE)
OK <- read.csv("web_scrape_8_OK.csv", stringsAsFactors=FALSE)
View(OK)
OK$Ad_Category <- sapply(strsplit(OK$Link, "/"),"[", 4)
# count duplicate phone numbers
2099 - length(na.omit(OK$Phone_Parsed))
length(na.omit(OK$Phone_Parsed))- length(unique(na.omit(OK$Phone_Parsed)))
#2099 obs: 430 NAs, 719 unique phone numbers (950 duplicates, 267 numbers have dup
length(OK$Phone_Parsed) - length(na.omit(OK$Phone_Parsed))
(length(OK$Phone_Parsed)-length(na.omit(OK$Phone_Parsed)))/length(OK$Phone_Parsed)
(length(na.omit(OK$Phone_Parsed))-length(unique(na.omit(OK$Phone_Parsed))))/length(OK$Phone_Parsed) #
phone_dup <- OK
phone_dup$freq <- 1
phone_dup <- na.omit(summaryBy(freq ~ Phone_Parsed,
data=phone_dup, FUN=sum))
phone_dup <- subset(phone_dup, phone_dup$freq.sum>1)
hist_1 <- hist(phone_dup$freq.sum, breaks = seq(1:63))
plot(hist_1, col="lightgray", main = "Distribution of Duplicate Phone Numbers",
xlab="Count", ylab = "Frequency")
phone_dup <- OK
phone_dup$freq <- 1
phone_dup <- na.omit(summaryBy(freq ~ Phone_Parsed,
data=phone_dup, FUN=sum))
phone_dup <- subset(phone_dup, phone_dup$freq.sum>1)
hist_1 <- hist(phone_dup$freq.sum, breaks = seq(1:max(phone_dup$freq.sum)))
plot(hist_1, col="lightgray", main = "Distribution of Duplicate Phone Numbers",
xlab="Count", ylab = "Frequency")
View(phone_dup)
View(phone_dup)
summary(phone_dup$freq.sum)
unique(OK$Date)
length(unique(OK$Link))
phone_dup$freq.sum-length(unique(OK$Link)) #There are three duplicates
length(phone_dup$freq.sum)-length(unique(OK$Link)) #There are three duplicates
length(OK$Link)-length(unique(OK$Link)) #There are three duplicates
unique(OK$Post)
length(unique(OK$Post))
ergm.call <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
offset(nodeicov("polity"))+offset(nodeocov("polity"))+
offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
offset(nodeicov("pop"))+offset(nodeocov("pop"))+
offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
nodeicov("polity")+nodeocov("polity")+
nodeicov("trade_opennes")+nodeocov("trade_opennes")+
nodeicov("pop")+nodeocov("pop")+
nodeicov("gdp.pc")+nodeocov("gdp.pc")+
edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the partially pooled ergm conducts a two-step meta analysis
# in the first step, coefficients are estimated for each network individually
# in the second step, all effects are fixed at the fixed effects meta analysis estimate, and only the
# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
# clear workspace, set seed, and set wd
rm(list=ls())
set.seed(19)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
ergmPooledMeta <- function(list_of_networks,ergm_call,ergm_call_no_offset,list_of_edgecovs=NULL,seed=1234,ncores=2){
require(ergm)
require(ergm.count)
require(doParallel)
require(foreach)
# ergm_call should be an expression
# time fixed effects are required
# formula should include all pooled terms in offset()
# network should be called 'net' in the formula
# edgecovs should be a T x Number_of_edgecovs length named list of matrices
# , where names(list_of_edgecovs[[t]])[i] is the matrix name used in the
# model formula
## Doing individual ergm estimation for pooling
registerDoParallel(cores=ncores)
ergms <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call_no_offset)
}
stopImplicitCluster()
print("finished stage 1")
coefMat <- NULL
weightMat <- NULL
meta.coef <- 0
varDenom <- 0
for(i in 1:length(list_of_networks)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
coefMat <- rbind(coefMat,coef(ergms[[i]]))
weightMat <- rbind(weightMat,1/(summary(ergms[[i]])$asyse)^2)
varDenom <- varDenom + weightMat[i,]
meta.coef <- meta.coef + coefMat[i,]*weightMat[i,]
}
meta.coef <- meta.coef/varDenom
SE <- sqrt(1/varDenom)
pooled_par <- meta.coef[-1]
registerDoParallel(cores=ncores)
ergms.pooled <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call)
}
stopImplicitCluster()
print("finished stage 2")
coefs <- meta.coef[-1]
SE  <- SE[-1]
loglik <- 0
for(i in 1:length(ergms.pooled)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
loglik <- loglik + as.numeric(logLik(ergms.pooled[[i]]))
coefs <- c(coefs,coef(ergms.pooled[[i]])[1])
SE <- c(SE,summary(ergms.pooled[[i]])$asyse[1])
}
AIC <- 2*length(coefs)-2*loglik
list(estimate=coefs,SE=SE,AIC=AIC,pooled.ergms=ergms.pooled)
}
### Load Libraries
library(ergm)
### Read in data
load("fdi_cov.Rdata")
load("fdi_net.Rdata")
# clear workspace, set seed, and set wd
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
ergmPooledMeta <- function(list_of_networks,ergm_call,ergm_call_no_offset,list_of_edgecovs=NULL,seed=1234,ncores=2){
require(ergm)
require(ergm.count)
require(doParallel)
require(foreach)
# ergm_call should be an expression
# time fixed effects are required
# formula should include all pooled terms in offset()
# network should be called 'net' in the formula
# edgecovs should be a T x Number_of_edgecovs length named list of matrices
# , where names(list_of_edgecovs[[t]])[i] is the matrix name used in the
# model formula
## Doing individual ergm estimation for pooling
registerDoParallel(cores=ncores)
ergms <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call_no_offset)
}
stopImplicitCluster()
print("finished stage 1")
coefMat <- NULL
weightMat <- NULL
meta.coef <- 0
varDenom <- 0
for(i in 1:length(list_of_networks)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
coefMat <- rbind(coefMat,coef(ergms[[i]]))
weightMat <- rbind(weightMat,1/(summary(ergms[[i]])$asyse)^2)
varDenom <- varDenom + weightMat[i,]
meta.coef <- meta.coef + coefMat[i,]*weightMat[i,]
}
meta.coef <- meta.coef/varDenom
SE <- sqrt(1/varDenom)
pooled_par <- meta.coef[-1]
registerDoParallel(cores=ncores)
ergms.pooled <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call)
}
stopImplicitCluster()
print("finished stage 2")
coefs <- meta.coef[-1]
SE  <- SE[-1]
loglik <- 0
for(i in 1:length(ergms.pooled)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
loglik <- loglik + as.numeric(logLik(ergms.pooled[[i]]))
coefs <- c(coefs,coef(ergms.pooled[[i]])[1])
SE <- c(SE,summary(ergms.pooled[[i]])$asyse[1])
}
AIC <- 2*length(coefs)-2*loglik
list(estimate=coefs,SE=SE,AIC=AIC,pooled.ergms=ergms.pooled)
}
### Load Libraries
library(ergm)
### Read in data
load("fdi_cov.Rdata")
load("fdi_net.Rdata")
ergm.call <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
offset(nodeicov("polity"))+offset(nodeocov("polity"))+
offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
offset(nodeicov("pop"))+offset(nodeocov("pop"))+
offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
nodeicov("polity")+nodeocov("polity")+
nodeicov("trade_opennes")+nodeocov("trade_opennes")+
nodeicov("pop")+nodeocov("pop")+
nodeicov("gdp.pc")+nodeocov("gdp.pc")+
edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
netlist[[1]]
# clear workspace
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#load packages
library(magic)
library(network)
library(igraph)
library(doBy)
library(plyr)
library(DataCombine)
#setwd("/Users/johnpschoeneman/Desktop/ACI/Count")
#load in data
fdi <- read.csv("sub_stock.csv", stringsAsFactors=FALSE)        #FDI
fdi <- fdi[,-1]
create new variable transformations
fdi$trade_ln <- log(fdi$trade_int+fdi$trade_hco+fdi$trade_cap+fdi$trade_mix+1)
fdi$dyad <- paste(fdi$Destination, fdi$Origin, sep = "")
fdi$mass <- (log(fdi$Dest.GDP*fdi$Origin.GDP))
fdi$dist_ln <- log(fdi$dist)
fdi$Value_ln <- round(log(ifelse(fdi$Value<0, 0, fdi$Value)+1))
fdi$Dest.pop_ln <- log(fdi$Dest.pop)
fdi$Origin.pop_ln <- log(fdi$Origin.pop)
#lag DV and GDP (to create growth rates)
fdi <- slide(fdi, Var = "Dest.GDP", GroupVar = "dyad", slideBy = -1)
fdi <- slide(fdi, Var = "Origin.GDP", GroupVar = "dyad", slideBy = -1)
fdi <- slide(fdi, Var = "Value_ln", GroupVar = "dyad", slideBy = -1)
#Create GDP pc (logged) and growth rate
fdi$Origin.GDPpc_ln <- log(fdi$Origin.GDP/fdi$Origin.pop)
fdi$Dest.GDPpc_ln <- log(fdi$Dest.GDP/fdi$Dest.pop)
fdi$Origin.GDPg <- (fdi$Origin.GDP-fdi$`Origin.GDP-1`)/fdi$`Origin.GDP-1`
fdi$Dest.GDPg <- (fdi$Dest.GDP-fdi$`Dest.GDP-1`)/fdi$`Dest.GDP-1`
#plot dependent variable distribution
fdi$Value_h <- ifelse(fdi$Value < 0, 0, fdi$Value)
fdi_col <- subset(fdi, fdi$Value_ln == 0)
fdi_h <- subset(fdi, fdi$Value_ln != 0)
fdi_col$Value  <- 1
fdi_col <- summaryBy(Value~Year, data = fdi_col, FUN=sum)
fdi_col$prop <- fdi_col$Value.sum/15500
#hist_1 <- hist(fdi$Value_h)
#hist_1$counts <- hist_1$counts/12
#plot(hist_1+1, col="lightgray", main = "Distribution of FDI Flows", ylim = c(0,600),
#     xlab="Value, logged (Excludes Zero Values, ~85% of obs.)", ylab = "Per Year")
par(mar = c(5,5,5,5))
boxplot(fdi_h$Value_h~fdi_h$Year, log = "y",col="lightgray", main = "Non-Zero FDI Stocks",yaxt='n',
xlab="Year", ylab = "FDI Stock (in mil USD)",outline=TRUE, cex=0.5, pch = 16, par(las=1))
axis(2,at=c(1, 100, 10000),labels=c("1","100","10K"))
#mtext("Removed Zeroes from Box-Plots")
par(new = T)
plot(fdi_col$prop, axes=F, xlab=NA, ylab=NA, type="l", col = "#D55E00", pch = 16)
axis(side = 4, col = "#D55E00", col.axis ="#D55E00",col.ticks="#D55E00")
par(las=0)
mtext(side = 4, line = 3, 'Proportion of Zeroes', col ="#D55E00")
rm(fdi_col, fdi_h, i, vars)
#125 countries, 12 years (2001-2012),
range_0to1 <- function(x){(x-min(x))/(max(x)-min(x))}
fdi <- na.omit(fdi)
#scale continuous variables
vars <- c(18:33,35, 37:49)
for(i in vars){
fdi[,i] <- range_0to1(fdi[,i])
}
fdi$alliance <- (fdi$nonaggression.max.x + fdi$entente.max.x + fdi$neutrality.max.x)
fdi$alliance <- as.numeric(ifelse(fdi$alliance >0, 1, 0))
#make bit  and defense numeric
fdi$bit_dummy <- as.numeric(fdi$bit_dummy)
fdi$defense.max.x <- as.numeric(fdi$defense.max.x)
View(fdi)
netlist <- list()
years <- 2002:2012
fdi_yr <- subset(fdi, fdi$Year == years[11])
vertex <- summaryBy(Origin.GDP+Origin.polity+Origin.TO+Origin.pop_ln +Origin.GDPg+
Origin.GDPpc_ln+Origin.pv ~ Origin, data=fdi_yr)
View(vertex)
names(vertex) <- c("name","GDP", "Polity", "TradeOpen", "Pop", "GDP.g","GDPpc", "PV")
fdi_yr <- subset(fdi, fdi$Year == years[i])
#turn into graph object
fdi_graph <- graph.data.frame(fdi_yr)
lag <- get.adjacency(fdi_graph,attr='Value_ln-1', sparse=FALSE)
fdi_yr <- subset(fdi, fdi$Year == years[11])
fdi_graph <- graph.data.frame(fdi_yr)
lag <- get.adjacency(fdi_graph,attr='Value_ln-1', sparse=FALSE)
View(lag)
mass <- get.adjacency(fdi_graph,attr='mass', sparse=FALSE)
dist <- get.adjacency(fdi_graph,attr='dist', sparse=FALSE)
alliance <- get.adjacency(fdi_graph,attr='alliance', sparse=FALSE)
defense <- get.adjacency(fdi_graph,attr='defense.max.x', sparse=FALSE)
trade_vol <- get.adjacency(fdi_graph,attr='trade_ln', sparse=FALSE)
bit <- get.adjacency(fdi_graph,attr='bit_dummy', sparse=FALSE)
View(alliance)
covlist_yr <- list(lag=lag, mass=mass, dist=dist, alliance = alliance,
defense= defense, trade_vol = trade_vol, bit = bit)
# clear workspace, set seed, and set wd
rm(list=ls())
set.seed(19)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
ergmPooledMeta <- function(list_of_networks,ergm_call,ergm_call_no_offset,list_of_edgecovs=NULL,seed=1234,ncores=2){
require(ergm)
require(ergm.count)
require(doParallel)
require(foreach)
# ergm_call should be an expression
# time fixed effects are required
# formula should include all pooled terms in offset()
# network should be called 'net' in the formula
# edgecovs should be a T x Number_of_edgecovs length named list of matrices
# , where names(list_of_edgecovs[[t]])[i] is the matrix name used in the
# model formula
## Doing individual ergm estimation for pooling
registerDoParallel(cores=ncores)
ergms <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call_no_offset)
}
stopImplicitCluster()
print("finished stage 1")
coefMat <- NULL
weightMat <- NULL
meta.coef <- 0
varDenom <- 0
for(i in 1:length(list_of_networks)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
coefMat <- rbind(coefMat,coef(ergms[[i]]))
weightMat <- rbind(weightMat,1/(summary(ergms[[i]])$asyse)^2)
varDenom <- varDenom + weightMat[i,]
meta.coef <- meta.coef + coefMat[i,]*weightMat[i,]
}
meta.coef <- meta.coef/varDenom
SE <- sqrt(1/varDenom)
pooled_par <- meta.coef[-1]
registerDoParallel(cores=ncores)
ergms.pooled <- foreach(i=1:length(list_of_networks)) %dopar% {
net <- list_of_networks[[i]]
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
set.seed(seed)
eval(ergm_call)
}
stopImplicitCluster()
print("finished stage 2")
coefs <- meta.coef[-1]
SE  <- SE[-1]
loglik <- 0
for(i in 1:length(ergms.pooled)){
if(length(list_of_networks)==length(list_of_edgecovs)){
edgecovars <- list_of_edgecovs[[i]]
}
loglik <- loglik + as.numeric(logLik(ergms.pooled[[i]]))
coefs <- c(coefs,coef(ergms.pooled[[i]])[1])
SE <- c(SE,summary(ergms.pooled[[i]])$asyse[1])
}
AIC <- 2*length(coefs)-2*loglik
list(estimate=coefs,SE=SE,AIC=AIC,pooled.ergms=ergms.pooled)
}
### Load Libraries
library(ergm)
### Read in data
load("fdi_cov.Rdata")
load("fdi_net.Rdata")
# the main ergm call is a complete call to ERGM wrapped in the expression() function. The differences for use in
# the ergmPooledMeta function are two-fold. First, all terms beside the edges term are wrapped in the 'offset()'
# function. Second, offset.coef is defined as pooled_par. These two differences are necessary for estimating the
# partially pooled models.
# note that edge covariates should be specified as edgecov(edgecovars[["nameOfMatrix"]])
#Node list: "polity","trade_opennes","pop","gdp.pc"
#Edge list:  lag, mass, dist, alliance, defense, trade_vol, bit
ergm.call <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
offset(nodeicov("polity"))+offset(nodeocov("polity"))+
offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
offset(nodeicov("pop"))+offset(nodeocov("pop"))+
offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc")),
#offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
#offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
#offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
#offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum + #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
nodeicov("polity")+nodeocov("polity")+
nodeicov("trade_opennes")+nodeocov("trade_opennes")+
nodeicov("pop")+nodeocov("pop")+
nodeicov("gdp.pc")+nodeocov("gdp.pc"),
#edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
#edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
#edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
#edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the partially pooled ergm conducts a two-step meta analysis
# in the first step, coefficients are estimated for each network individually
# in the second step, all effects are fixed at the fixed effects meta analysis estimate, and only the
# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
ergm.call <- expression(ergm(net ~ sum, #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
#offset(nodeicov("polity"))+offset(nodeocov("polity"))+
#offset(nodeicov("trade_opennes"))+offset(nodeocov("trade_opennes"))+
#offset(nodeicov("pop"))+offset(nodeocov("pop"))+
#offset(nodeicov("gdp.pc"))+offset(nodeocov("gdp.pc"))+
#offset(edgecov(edgecovars[[1]]))+offset(edgecov(edgecovars[[2]]))+
#offset(edgecov(edgecovars[[3]]))+offset(edgecov(edgecovars[[4]]))+
#offset(edgecov(edgecovars[[5]]))+offset(edgecov(edgecovars[[6]]))+
#offset(edgecov(edgecovars[[7]])),
offset.coef=pooled_par,
response="Value_ln",
reference=~Poisson))
# the no offset call strips the ERGM call of the offset() function and the offset.coef argument
# terms must match and be in the same order
ergm.call.no.offset <- expression(ergm(net ~ sum, #sum(pow=1/2)+ nonzero +
#mutual(form="min")+transitiveweights("min", "max", "min")+
#nodeicov("polity")+nodeocov("polity")+
#nodeicov("trade_opennes")+nodeocov("trade_opennes")+
#nodeicov("pop")+nodeocov("pop")+
#nodeicov("gdp.pc")+nodeocov("gdp.pc")+
#edgecov(edgecovars[[1]])+edgecov(edgecovars[[2]])+
#edgecov(edgecovars[[3]])+edgecov(edgecovars[[4]])+
#edgecov(edgecovars[[5]])+edgecov(edgecovars[[6]])+
#edgecov(edgecovars[[7]]),
response="Value_ln",
reference=~Poisson))
# the partially pooled ergm conducts a two-step meta analysis
# in the first step, coefficients are estimated for each network individually
# in the second step, all effects are fixed at the fixed effects meta analysis estimate, and only the
# intercepts are estimated for each network
# The results include the pooled coefficients (note network-specific intercepts are at the end), SEs, AIC,
# and the ergm opjects from the second stage of pooled estimation
# MCMC diagnostics can be run on the second-stage ERGM results.
pooledERGMres <- ergmPooledMeta(list_of_networks=netlist,ergm_call=ergm.call,ergm_call_no_offset=ergm.call.no.offset,list_of_edgecovs=covlist)
